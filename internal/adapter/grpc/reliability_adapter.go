package grpc

import (
	"context"
	"fmt"
	"io"
	"log"
	"strconv"

	rel "github.com/timpamungkas/grpc-proto/protogen/go/reliability"

	drel "github.com/timpamungkas/grpc-go-server/internal/application/domain/reliability"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func generateErrStatus(statusCode uint32) error {
	str := "Generated by server"

	switch statusCode {
	case drel.OK:
		return nil
	case drel.CANCELLED:
		return status.New(codes.Canceled, str).Err()
	case drel.UNKNOWN:
		return status.New(codes.Unknown, str).Err()
	case drel.INVALID_ARGUMENT:
		return status.New(codes.InvalidArgument, str).Err()
	case drel.DEADLINE_EXCEEDED:
		return status.New(codes.DeadlineExceeded, str).Err()
	case drel.NOT_FOUND:
		return status.New(codes.NotFound, str).Err()
	case drel.ALREADY_EXISTS:
		return status.New(codes.AlreadyExists, str).Err()
	default:
		return status.New(codes.Internal, str).Err()
	}
}

func (a *GrpcAdapter) UnaryReliability(ctx context.Context, in *rel.ReliabilityRequest) (*rel.ReliabilityResponse, error) {
	str, sts := a.reliabilityService.GenerateReliability(in.MinDelaySecond, in.MaxDelaySecond, in.StatusCodes)

	if errStatus := generateErrStatus(sts); errStatus != nil {
		return nil, errStatus
	}

	return &rel.ReliabilityResponse{
		DummyString: str,
	}, nil
}

func (a *GrpcAdapter) ServerStreamingReliability(in *rel.ReliabilityRequest, stream rel.ReliabilityService_ServerStreamingReliabilityServer) error {
	context := stream.Context()

	for {
		select {
		case <-context.Done():
			log.Println("Client cancelled request")
			return nil
		default:
			str, sts := a.reliabilityService.GenerateReliability(in.MinDelaySecond, in.MaxDelaySecond, in.StatusCodes)

			if errStatus := generateErrStatus(sts); errStatus != nil {
				return errStatus
			}

			stream.Send(
				&rel.ReliabilityResponse{
					DummyString: str,
				},
			)
		}
	}
}

func (a *GrpcAdapter) ClientStreamingReliability(stream rel.ReliabilityService_ClientStreamingReliabilityServer) error {
	i := 0

	for {
		in, err := stream.Recv()
		i = i + 1

		if err == io.EOF {
			res := rel.ReliabilityResponse{
				DummyString: fmt.Sprintf("Received %v requests from client", strconv.Itoa(i)),
			}

			return stream.SendAndClose(
				&res,
			)
		}

		_, sts := a.reliabilityService.GenerateReliability(
			in.MinDelaySecond, in.MaxDelaySecond, in.StatusCodes)

		if errStatus := generateErrStatus(sts); errStatus != nil {
			return errStatus
		}
	}
}

func (a *GrpcAdapter) BiDirectionalReliability(stream rel.ReliabilityService_BiDirectionalReliabilityServer) error {
	context := stream.Context()

	for {
		select {
		case <-context.Done():
			log.Println("Client cancelled request")
			return nil
		default:
			req, err := stream.Recv()

			if err == io.EOF {
				return nil
			}

			if err != nil {
				log.Fatalf("Error while reading from client : %v", err)
			}

			str, sts := a.reliabilityService.GenerateReliability(
				req.MinDelaySecond, req.MaxDelaySecond, req.StatusCodes)

			if errStatus := generateErrStatus(sts); errStatus != nil {
				return errStatus
			}

			err = stream.Send(
				&rel.ReliabilityResponse{
					DummyString: str,
				},
			)

			if err != nil {
				log.Fatalf("Error while sending response to client : %v", err)
			}
		}
	}
}
